// proto - bitdrift's client/server API definitions
// Copyright Bitdrift, Inc. All rights reserved.
//
// Use of this source code and APIs are governed by a source available license that can be found in
// the LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc 33.0
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `pulse/internode/v1/metric.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_4_0_0_ALPHA_0;

// @@protoc_insertion_point(message:pulse.internode.v1.Histogram)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Histogram {
    // message fields
    // @@protoc_insertion_point(field:pulse.internode.v1.Histogram.buckets)
    pub buckets: ::std::vec::Vec<histogram::Bucket>,
    // @@protoc_insertion_point(field:pulse.internode.v1.Histogram.sample_count)
    pub sample_count: f64,
    // @@protoc_insertion_point(field:pulse.internode.v1.Histogram.sample_sum)
    pub sample_sum: f64,
    // special fields
    // @@protoc_insertion_point(special_field:pulse.internode.v1.Histogram.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Histogram {
    fn default() -> &'a Histogram {
        <Histogram as ::protobuf::Message>::default_instance()
    }
}

impl Histogram {
    pub fn new() -> Histogram {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buckets",
            |m: &Histogram| { &m.buckets },
            |m: &mut Histogram| { &mut m.buckets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sample_count",
            |m: &Histogram| { &m.sample_count },
            |m: &mut Histogram| { &mut m.sample_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sample_sum",
            |m: &Histogram| { &m.sample_sum },
            |m: &mut Histogram| { &mut m.sample_sum },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Histogram>(
            "Histogram",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Histogram {
    const NAME: &'static str = "Histogram";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.buckets.push(is.read_message()?);
                },
                17 => {
                    self.sample_count = is.read_double()?;
                },
                25 => {
                    self.sample_sum = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.buckets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.sample_count != 0. {
            my_size += 1 + 8;
        }
        if self.sample_sum != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.buckets {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.sample_count != 0. {
            os.write_double(2, self.sample_count)?;
        }
        if self.sample_sum != 0. {
            os.write_double(3, self.sample_sum)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Histogram {
        Histogram::new()
    }

    fn clear(&mut self) {
        self.buckets.clear();
        self.sample_count = 0.;
        self.sample_sum = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Histogram {
        static instance: Histogram = Histogram {
            buckets: ::std::vec::Vec::new(),
            sample_count: 0.,
            sample_sum: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Histogram {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Histogram").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Histogram {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Histogram {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Histogram`
pub mod histogram {
    // @@protoc_insertion_point(message:pulse.internode.v1.Histogram.Bucket)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Bucket {
        // message fields
        // @@protoc_insertion_point(field:pulse.internode.v1.Histogram.Bucket.count)
        pub count: f64,
        // @@protoc_insertion_point(field:pulse.internode.v1.Histogram.Bucket.le)
        pub le: f64,
        // special fields
        // @@protoc_insertion_point(special_field:pulse.internode.v1.Histogram.Bucket.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Bucket {
        fn default() -> &'a Bucket {
            <Bucket as ::protobuf::Message>::default_instance()
        }
    }

    impl Bucket {
        pub fn new() -> Bucket {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "count",
                |m: &Bucket| { &m.count },
                |m: &mut Bucket| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "le",
                |m: &Bucket| { &m.le },
                |m: &mut Bucket| { &mut m.le },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Bucket>(
                "Histogram.Bucket",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Bucket {
        const NAME: &'static str = "Bucket";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.count = is.read_double()?;
                    },
                    17 => {
                        self.le = is.read_double()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.count != 0. {
                my_size += 1 + 8;
            }
            if self.le != 0. {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.count != 0. {
                os.write_double(1, self.count)?;
            }
            if self.le != 0. {
                os.write_double(2, self.le)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Bucket {
            Bucket::new()
        }

        fn clear(&mut self) {
            self.count = 0.;
            self.le = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Bucket {
            static instance: Bucket = Bucket {
                count: 0.,
                le: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Bucket {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Histogram.Bucket").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Bucket {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Bucket {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:pulse.internode.v1.Summary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Summary {
    // message fields
    // @@protoc_insertion_point(field:pulse.internode.v1.Summary.quantiles)
    pub quantiles: ::std::vec::Vec<summary::Quantile>,
    // @@protoc_insertion_point(field:pulse.internode.v1.Summary.sample_count)
    pub sample_count: f64,
    // @@protoc_insertion_point(field:pulse.internode.v1.Summary.sample_sum)
    pub sample_sum: f64,
    // special fields
    // @@protoc_insertion_point(special_field:pulse.internode.v1.Summary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Summary {
    fn default() -> &'a Summary {
        <Summary as ::protobuf::Message>::default_instance()
    }
}

impl Summary {
    pub fn new() -> Summary {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "quantiles",
            |m: &Summary| { &m.quantiles },
            |m: &mut Summary| { &mut m.quantiles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sample_count",
            |m: &Summary| { &m.sample_count },
            |m: &mut Summary| { &mut m.sample_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sample_sum",
            |m: &Summary| { &m.sample_sum },
            |m: &mut Summary| { &mut m.sample_sum },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Summary>(
            "Summary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Summary {
    const NAME: &'static str = "Summary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.quantiles.push(is.read_message()?);
                },
                17 => {
                    self.sample_count = is.read_double()?;
                },
                25 => {
                    self.sample_sum = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.quantiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.sample_count != 0. {
            my_size += 1 + 8;
        }
        if self.sample_sum != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.quantiles {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.sample_count != 0. {
            os.write_double(2, self.sample_count)?;
        }
        if self.sample_sum != 0. {
            os.write_double(3, self.sample_sum)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Summary {
        Summary::new()
    }

    fn clear(&mut self) {
        self.quantiles.clear();
        self.sample_count = 0.;
        self.sample_sum = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Summary {
        static instance: Summary = Summary {
            quantiles: ::std::vec::Vec::new(),
            sample_count: 0.,
            sample_sum: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Summary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Summary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Summary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Summary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Summary`
pub mod summary {
    // @@protoc_insertion_point(message:pulse.internode.v1.Summary.Quantile)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Quantile {
        // message fields
        // @@protoc_insertion_point(field:pulse.internode.v1.Summary.Quantile.quantile)
        pub quantile: f64,
        // @@protoc_insertion_point(field:pulse.internode.v1.Summary.Quantile.value)
        pub value: f64,
        // special fields
        // @@protoc_insertion_point(special_field:pulse.internode.v1.Summary.Quantile.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Quantile {
        fn default() -> &'a Quantile {
            <Quantile as ::protobuf::Message>::default_instance()
        }
    }

    impl Quantile {
        pub fn new() -> Quantile {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "quantile",
                |m: &Quantile| { &m.quantile },
                |m: &mut Quantile| { &mut m.quantile },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &Quantile| { &m.value },
                |m: &mut Quantile| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Quantile>(
                "Summary.Quantile",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Quantile {
        const NAME: &'static str = "Quantile";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.quantile = is.read_double()?;
                    },
                    17 => {
                        self.value = is.read_double()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.quantile != 0. {
                my_size += 1 + 8;
            }
            if self.value != 0. {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.quantile != 0. {
                os.write_double(1, self.quantile)?;
            }
            if self.value != 0. {
                os.write_double(2, self.value)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Quantile {
            Quantile::new()
        }

        fn clear(&mut self) {
            self.quantile = 0.;
            self.value = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Quantile {
            static instance: Quantile = Quantile {
                quantile: 0.,
                value: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Quantile {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Summary.Quantile").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Quantile {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Quantile {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:pulse.internode.v1.DownstreamId)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DownstreamId {
    // message oneof groups
    pub id_type: ::std::option::Option<downstream_id::Id_type>,
    // special fields
    // @@protoc_insertion_point(special_field:pulse.internode.v1.DownstreamId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DownstreamId {
    fn default() -> &'a DownstreamId {
        <DownstreamId as ::protobuf::Message>::default_instance()
    }
}

impl DownstreamId {
    pub fn new() -> DownstreamId {
        ::std::default::Default::default()
    }

    // bool local_origin = 1;

    pub fn local_origin(&self) -> bool {
        match self.id_type {
            ::std::option::Option::Some(downstream_id::Id_type::LocalOrigin(v)) => v,
            _ => false,
        }
    }

    pub fn clear_local_origin(&mut self) {
        self.id_type = ::std::option::Option::None;
    }

    pub fn has_local_origin(&self) -> bool {
        match self.id_type {
            ::std::option::Option::Some(downstream_id::Id_type::LocalOrigin(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_local_origin(&mut self, v: bool) {
        self.id_type = ::std::option::Option::Some(downstream_id::Id_type::LocalOrigin(v))
    }

    // string unix_domain_socket = 2;

    pub fn unix_domain_socket(&self) -> &str {
        match self.id_type {
            ::std::option::Option::Some(downstream_id::Id_type::UnixDomainSocket(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_unix_domain_socket(&mut self) {
        self.id_type = ::std::option::Option::None;
    }

    pub fn has_unix_domain_socket(&self) -> bool {
        match self.id_type {
            ::std::option::Option::Some(downstream_id::Id_type::UnixDomainSocket(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unix_domain_socket(&mut self, v: ::protobuf::Chars) {
        self.id_type = ::std::option::Option::Some(downstream_id::Id_type::UnixDomainSocket(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unix_domain_socket(&mut self) -> &mut ::protobuf::Chars {
        if let ::std::option::Option::Some(downstream_id::Id_type::UnixDomainSocket(_)) = self.id_type {
        } else {
            self.id_type = ::std::option::Option::Some(downstream_id::Id_type::UnixDomainSocket(::protobuf::Chars::new()));
        }
        match self.id_type {
            ::std::option::Option::Some(downstream_id::Id_type::UnixDomainSocket(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unix_domain_socket(&mut self) -> ::protobuf::Chars {
        if self.has_unix_domain_socket() {
            match self.id_type.take() {
                ::std::option::Option::Some(downstream_id::Id_type::UnixDomainSocket(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::Chars::new()
        }
    }

    // uint32 ipv4_address = 3;

    pub fn ipv4_address(&self) -> u32 {
        match self.id_type {
            ::std::option::Option::Some(downstream_id::Id_type::Ipv4Address(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_ipv4_address(&mut self) {
        self.id_type = ::std::option::Option::None;
    }

    pub fn has_ipv4_address(&self) -> bool {
        match self.id_type {
            ::std::option::Option::Some(downstream_id::Id_type::Ipv4Address(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ipv4_address(&mut self, v: u32) {
        self.id_type = ::std::option::Option::Some(downstream_id::Id_type::Ipv4Address(v))
    }

    // bytes ipv6_address = 4;

    pub fn ipv6_address(&self) -> &[u8] {
        match self.id_type {
            ::std::option::Option::Some(downstream_id::Id_type::Ipv6Address(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_ipv6_address(&mut self) {
        self.id_type = ::std::option::Option::None;
    }

    pub fn has_ipv6_address(&self) -> bool {
        match self.id_type {
            ::std::option::Option::Some(downstream_id::Id_type::Ipv6Address(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ipv6_address(&mut self, v: ::bytes::Bytes) {
        self.id_type = ::std::option::Option::Some(downstream_id::Id_type::Ipv6Address(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ipv6_address(&mut self) -> &mut ::bytes::Bytes {
        if let ::std::option::Option::Some(downstream_id::Id_type::Ipv6Address(_)) = self.id_type {
        } else {
            self.id_type = ::std::option::Option::Some(downstream_id::Id_type::Ipv6Address(::bytes::Bytes::new()));
        }
        match self.id_type {
            ::std::option::Option::Some(downstream_id::Id_type::Ipv6Address(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ipv6_address(&mut self) -> ::bytes::Bytes {
        if self.has_ipv6_address() {
            match self.id_type.take() {
                ::std::option::Option::Some(downstream_id::Id_type::Ipv6Address(v)) => v,
                _ => panic!(),
            }
        } else {
            ::bytes::Bytes::new()
        }
    }

    // bytes inflow_provided = 5;

    pub fn inflow_provided(&self) -> &[u8] {
        match self.id_type {
            ::std::option::Option::Some(downstream_id::Id_type::InflowProvided(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_inflow_provided(&mut self) {
        self.id_type = ::std::option::Option::None;
    }

    pub fn has_inflow_provided(&self) -> bool {
        match self.id_type {
            ::std::option::Option::Some(downstream_id::Id_type::InflowProvided(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_inflow_provided(&mut self, v: ::bytes::Bytes) {
        self.id_type = ::std::option::Option::Some(downstream_id::Id_type::InflowProvided(v))
    }

    // Mutable pointer to the field.
    pub fn mut_inflow_provided(&mut self) -> &mut ::bytes::Bytes {
        if let ::std::option::Option::Some(downstream_id::Id_type::InflowProvided(_)) = self.id_type {
        } else {
            self.id_type = ::std::option::Option::Some(downstream_id::Id_type::InflowProvided(::bytes::Bytes::new()));
        }
        match self.id_type {
            ::std::option::Option::Some(downstream_id::Id_type::InflowProvided(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_inflow_provided(&mut self) -> ::bytes::Bytes {
        if self.has_inflow_provided() {
            match self.id_type.take() {
                ::std::option::Option::Some(downstream_id::Id_type::InflowProvided(v)) => v,
                _ => panic!(),
            }
        } else {
            ::bytes::Bytes::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "local_origin",
            DownstreamId::has_local_origin,
            DownstreamId::local_origin,
            DownstreamId::set_local_origin,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "unix_domain_socket",
            DownstreamId::has_unix_domain_socket,
            DownstreamId::unix_domain_socket,
            DownstreamId::set_unix_domain_socket,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "ipv4_address",
            DownstreamId::has_ipv4_address,
            DownstreamId::ipv4_address,
            DownstreamId::set_ipv4_address,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "ipv6_address",
            DownstreamId::has_ipv6_address,
            DownstreamId::ipv6_address,
            DownstreamId::set_ipv6_address,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "inflow_provided",
            DownstreamId::has_inflow_provided,
            DownstreamId::inflow_provided,
            DownstreamId::set_inflow_provided,
        ));
        oneofs.push(downstream_id::Id_type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DownstreamId>(
            "DownstreamId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DownstreamId {
    const NAME: &'static str = "DownstreamId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id_type = ::std::option::Option::Some(downstream_id::Id_type::LocalOrigin(is.read_bool()?));
                },
                18 => {
                    self.id_type = ::std::option::Option::Some(downstream_id::Id_type::UnixDomainSocket(is.read_tokio_chars()?));
                },
                24 => {
                    self.id_type = ::std::option::Option::Some(downstream_id::Id_type::Ipv4Address(is.read_uint32()?));
                },
                34 => {
                    self.id_type = ::std::option::Option::Some(downstream_id::Id_type::Ipv6Address(is.read_tokio_bytes()?));
                },
                42 => {
                    self.id_type = ::std::option::Option::Some(downstream_id::Id_type::InflowProvided(is.read_tokio_bytes()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.id_type {
            match v {
                &downstream_id::Id_type::LocalOrigin(v) => {
                    my_size += 1 + 1;
                },
                &downstream_id::Id_type::UnixDomainSocket(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &downstream_id::Id_type::Ipv4Address(v) => {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                },
                &downstream_id::Id_type::Ipv6Address(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
                &downstream_id::Id_type::InflowProvided(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(5, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.id_type {
            match v {
                &downstream_id::Id_type::LocalOrigin(v) => {
                    os.write_bool(1, v)?;
                },
                &downstream_id::Id_type::UnixDomainSocket(ref v) => {
                    os.write_string(2, v)?;
                },
                &downstream_id::Id_type::Ipv4Address(v) => {
                    os.write_uint32(3, v)?;
                },
                &downstream_id::Id_type::Ipv6Address(ref v) => {
                    os.write_bytes(4, v)?;
                },
                &downstream_id::Id_type::InflowProvided(ref v) => {
                    os.write_bytes(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DownstreamId {
        DownstreamId::new()
    }

    fn clear(&mut self) {
        self.id_type = ::std::option::Option::None;
        self.id_type = ::std::option::Option::None;
        self.id_type = ::std::option::Option::None;
        self.id_type = ::std::option::Option::None;
        self.id_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DownstreamId {
        static instance: DownstreamId = DownstreamId {
            id_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DownstreamId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DownstreamId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DownstreamId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownstreamId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DownstreamId`
pub mod downstream_id {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:pulse.internode.v1.DownstreamId.id_type)
    pub enum Id_type {
        // @@protoc_insertion_point(oneof_field:pulse.internode.v1.DownstreamId.local_origin)
        LocalOrigin(bool),
        // @@protoc_insertion_point(oneof_field:pulse.internode.v1.DownstreamId.unix_domain_socket)
        UnixDomainSocket(::protobuf::Chars),
        // @@protoc_insertion_point(oneof_field:pulse.internode.v1.DownstreamId.ipv4_address)
        Ipv4Address(u32),
        // @@protoc_insertion_point(oneof_field:pulse.internode.v1.DownstreamId.ipv6_address)
        Ipv6Address(::bytes::Bytes),
        // @@protoc_insertion_point(oneof_field:pulse.internode.v1.DownstreamId.inflow_provided)
        InflowProvided(::bytes::Bytes),
    }

    impl ::protobuf::Oneof for Id_type {
    }

    impl ::protobuf::OneofFull for Id_type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::DownstreamId as ::protobuf::MessageFull>::descriptor().oneof_by_name("id_type").unwrap()).clone()
        }
    }

    impl Id_type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Id_type>("id_type")
        }
    }
}

// @@protoc_insertion_point(message:pulse.internode.v1.BulkTimer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BulkTimer {
    // message fields
    // @@protoc_insertion_point(field:pulse.internode.v1.BulkTimer.values)
    pub values: ::std::vec::Vec<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:pulse.internode.v1.BulkTimer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BulkTimer {
    fn default() -> &'a BulkTimer {
        <BulkTimer as ::protobuf::Message>::default_instance()
    }
}

impl BulkTimer {
    pub fn new() -> BulkTimer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &BulkTimer| { &m.values },
            |m: &mut BulkTimer| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BulkTimer>(
            "BulkTimer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BulkTimer {
    const NAME: &'static str = "BulkTimer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_double_into(&mut self.values)?;
                },
                9 => {
                    self.values.push(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_double_size(1, &self.values);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_double(1, &self.values)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BulkTimer {
        BulkTimer::new()
    }

    fn clear(&mut self) {
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BulkTimer {
        static instance: BulkTimer = BulkTimer {
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BulkTimer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BulkTimer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BulkTimer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkTimer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pulse.internode.v1.Metric)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Metric {
    // message fields
    // @@protoc_insertion_point(field:pulse.internode.v1.Metric.id)
    pub id: ::protobuf::MessageField<MetricId>,
    // @@protoc_insertion_point(field:pulse.internode.v1.Metric.sample_rate)
    pub sample_rate: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:pulse.internode.v1.Metric.timestamp)
    pub timestamp: u64,
    // @@protoc_insertion_point(field:pulse.internode.v1.Metric.metric_source)
    pub metric_source: ::protobuf::MessageField<MetricSource>,
    // @@protoc_insertion_point(field:pulse.internode.v1.Metric.received_at)
    pub received_at: u64,
    // @@protoc_insertion_point(field:pulse.internode.v1.Metric.downstream_id)
    pub downstream_id: ::protobuf::MessageField<DownstreamId>,
    // message oneof groups
    pub value_type: ::std::option::Option<metric::Value_type>,
    // special fields
    // @@protoc_insertion_point(special_field:pulse.internode.v1.Metric.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Metric {
    fn default() -> &'a Metric {
        <Metric as ::protobuf::Message>::default_instance()
    }
}

impl Metric {
    pub fn new() -> Metric {
        ::std::default::Default::default()
    }

    // double simple_value = 4;

    pub fn simple_value(&self) -> f64 {
        match self.value_type {
            ::std::option::Option::Some(metric::Value_type::SimpleValue(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_simple_value(&mut self) {
        self.value_type = ::std::option::Option::None;
    }

    pub fn has_simple_value(&self) -> bool {
        match self.value_type {
            ::std::option::Option::Some(metric::Value_type::SimpleValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_simple_value(&mut self, v: f64) {
        self.value_type = ::std::option::Option::Some(metric::Value_type::SimpleValue(v))
    }

    // .pulse.internode.v1.Histogram histogram = 5;

    pub fn histogram(&self) -> &Histogram {
        match self.value_type {
            ::std::option::Option::Some(metric::Value_type::Histogram(ref v)) => v,
            _ => <Histogram as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_histogram(&mut self) {
        self.value_type = ::std::option::Option::None;
    }

    pub fn has_histogram(&self) -> bool {
        match self.value_type {
            ::std::option::Option::Some(metric::Value_type::Histogram(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_histogram(&mut self, v: Histogram) {
        self.value_type = ::std::option::Option::Some(metric::Value_type::Histogram(v))
    }

    // Mutable pointer to the field.
    pub fn mut_histogram(&mut self) -> &mut Histogram {
        if let ::std::option::Option::Some(metric::Value_type::Histogram(_)) = self.value_type {
        } else {
            self.value_type = ::std::option::Option::Some(metric::Value_type::Histogram(Histogram::new()));
        }
        match self.value_type {
            ::std::option::Option::Some(metric::Value_type::Histogram(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_histogram(&mut self) -> Histogram {
        if self.has_histogram() {
            match self.value_type.take() {
                ::std::option::Option::Some(metric::Value_type::Histogram(v)) => v,
                _ => panic!(),
            }
        } else {
            Histogram::new()
        }
    }

    // .pulse.internode.v1.Summary summary = 6;

    pub fn summary(&self) -> &Summary {
        match self.value_type {
            ::std::option::Option::Some(metric::Value_type::Summary(ref v)) => v,
            _ => <Summary as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_summary(&mut self) {
        self.value_type = ::std::option::Option::None;
    }

    pub fn has_summary(&self) -> bool {
        match self.value_type {
            ::std::option::Option::Some(metric::Value_type::Summary(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: Summary) {
        self.value_type = ::std::option::Option::Some(metric::Value_type::Summary(v))
    }

    // Mutable pointer to the field.
    pub fn mut_summary(&mut self) -> &mut Summary {
        if let ::std::option::Option::Some(metric::Value_type::Summary(_)) = self.value_type {
        } else {
            self.value_type = ::std::option::Option::Some(metric::Value_type::Summary(Summary::new()));
        }
        match self.value_type {
            ::std::option::Option::Some(metric::Value_type::Summary(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_summary(&mut self) -> Summary {
        if self.has_summary() {
            match self.value_type.take() {
                ::std::option::Option::Some(metric::Value_type::Summary(v)) => v,
                _ => panic!(),
            }
        } else {
            Summary::new()
        }
    }

    // .pulse.internode.v1.BulkTimer bulk_timer = 10;

    pub fn bulk_timer(&self) -> &BulkTimer {
        match self.value_type {
            ::std::option::Option::Some(metric::Value_type::BulkTimer(ref v)) => v,
            _ => <BulkTimer as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_bulk_timer(&mut self) {
        self.value_type = ::std::option::Option::None;
    }

    pub fn has_bulk_timer(&self) -> bool {
        match self.value_type {
            ::std::option::Option::Some(metric::Value_type::BulkTimer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bulk_timer(&mut self, v: BulkTimer) {
        self.value_type = ::std::option::Option::Some(metric::Value_type::BulkTimer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bulk_timer(&mut self) -> &mut BulkTimer {
        if let ::std::option::Option::Some(metric::Value_type::BulkTimer(_)) = self.value_type {
        } else {
            self.value_type = ::std::option::Option::Some(metric::Value_type::BulkTimer(BulkTimer::new()));
        }
        match self.value_type {
            ::std::option::Option::Some(metric::Value_type::BulkTimer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bulk_timer(&mut self) -> BulkTimer {
        if self.has_bulk_timer() {
            match self.value_type.take() {
                ::std::option::Option::Some(metric::Value_type::BulkTimer(v)) => v,
                _ => panic!(),
            }
        } else {
            BulkTimer::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MetricId>(
            "id",
            |m: &Metric| { &m.id },
            |m: &mut Metric| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sample_rate",
            |m: &Metric| { &m.sample_rate },
            |m: &mut Metric| { &mut m.sample_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &Metric| { &m.timestamp },
            |m: &mut Metric| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "simple_value",
            Metric::has_simple_value,
            Metric::simple_value,
            Metric::set_simple_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Histogram>(
            "histogram",
            Metric::has_histogram,
            Metric::histogram,
            Metric::mut_histogram,
            Metric::set_histogram,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Summary>(
            "summary",
            Metric::has_summary,
            Metric::summary,
            Metric::mut_summary,
            Metric::set_summary,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BulkTimer>(
            "bulk_timer",
            Metric::has_bulk_timer,
            Metric::bulk_timer,
            Metric::mut_bulk_timer,
            Metric::set_bulk_timer,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MetricSource>(
            "metric_source",
            |m: &Metric| { &m.metric_source },
            |m: &mut Metric| { &mut m.metric_source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "received_at",
            |m: &Metric| { &m.received_at },
            |m: &mut Metric| { &mut m.received_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DownstreamId>(
            "downstream_id",
            |m: &Metric| { &m.downstream_id },
            |m: &mut Metric| { &mut m.downstream_id },
        ));
        oneofs.push(metric::Value_type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Metric>(
            "Metric",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Metric {
    const NAME: &'static str = "Metric";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.id)?;
                },
                17 => {
                    self.sample_rate = ::std::option::Option::Some(is.read_double()?);
                },
                24 => {
                    self.timestamp = is.read_uint64()?;
                },
                33 => {
                    self.value_type = ::std::option::Option::Some(metric::Value_type::SimpleValue(is.read_double()?));
                },
                42 => {
                    self.value_type = ::std::option::Option::Some(metric::Value_type::Histogram(is.read_message()?));
                },
                50 => {
                    self.value_type = ::std::option::Option::Some(metric::Value_type::Summary(is.read_message()?));
                },
                82 => {
                    self.value_type = ::std::option::Option::Some(metric::Value_type::BulkTimer(is.read_message()?));
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metric_source)?;
                },
                64 => {
                    self.received_at = is.read_uint64()?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.downstream_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sample_rate {
            my_size += 1 + 8;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.timestamp);
        }
        if let Some(v) = self.metric_source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.received_at != 0 {
            my_size += ::protobuf::rt::uint64_size(8, self.received_at);
        }
        if let Some(v) = self.downstream_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.value_type {
            match v {
                &metric::Value_type::SimpleValue(v) => {
                    my_size += 1 + 8;
                },
                &metric::Value_type::Histogram(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &metric::Value_type::Summary(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &metric::Value_type::BulkTimer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.sample_rate {
            os.write_double(2, v)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(3, self.timestamp)?;
        }
        if let Some(v) = self.metric_source.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if self.received_at != 0 {
            os.write_uint64(8, self.received_at)?;
        }
        if let Some(v) = self.downstream_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value_type {
            match v {
                &metric::Value_type::SimpleValue(v) => {
                    os.write_double(4, v)?;
                },
                &metric::Value_type::Histogram(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &metric::Value_type::Summary(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &metric::Value_type::BulkTimer(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Metric {
        Metric::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.sample_rate = ::std::option::Option::None;
        self.timestamp = 0;
        self.value_type = ::std::option::Option::None;
        self.value_type = ::std::option::Option::None;
        self.value_type = ::std::option::Option::None;
        self.value_type = ::std::option::Option::None;
        self.metric_source.clear();
        self.received_at = 0;
        self.downstream_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Metric {
        static instance: Metric = Metric {
            id: ::protobuf::MessageField::none(),
            sample_rate: ::std::option::Option::None,
            timestamp: 0,
            metric_source: ::protobuf::MessageField::none(),
            received_at: 0,
            downstream_id: ::protobuf::MessageField::none(),
            value_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Metric {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Metric").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Metric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Metric {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Metric`
pub mod metric {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:pulse.internode.v1.Metric.value_type)
    pub enum Value_type {
        // @@protoc_insertion_point(oneof_field:pulse.internode.v1.Metric.simple_value)
        SimpleValue(f64),
        // @@protoc_insertion_point(oneof_field:pulse.internode.v1.Metric.histogram)
        Histogram(super::Histogram),
        // @@protoc_insertion_point(oneof_field:pulse.internode.v1.Metric.summary)
        Summary(super::Summary),
        // @@protoc_insertion_point(oneof_field:pulse.internode.v1.Metric.bulk_timer)
        BulkTimer(super::BulkTimer),
    }

    impl ::protobuf::Oneof for Value_type {
    }

    impl ::protobuf::OneofFull for Value_type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Metric as ::protobuf::MessageFull>::descriptor().oneof_by_name("value_type").unwrap()).clone()
        }
    }

    impl Value_type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value_type>("value_type")
        }
    }
}

// @@protoc_insertion_point(message:pulse.internode.v1.MetricSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MetricSource {
    // message fields
    // @@protoc_insertion_point(field:pulse.internode.v1.MetricSource.wire_protocol)
    pub wire_protocol: ::protobuf::EnumOrUnknown<WireProtocol>,
    // @@protoc_insertion_point(field:pulse.internode.v1.MetricSource.original)
    pub original: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:pulse.internode.v1.MetricSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MetricSource {
    fn default() -> &'a MetricSource {
        <MetricSource as ::protobuf::Message>::default_instance()
    }
}

impl MetricSource {
    pub fn new() -> MetricSource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wire_protocol",
            |m: &MetricSource| { &m.wire_protocol },
            |m: &mut MetricSource| { &mut m.wire_protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "original",
            |m: &MetricSource| { &m.original },
            |m: &mut MetricSource| { &mut m.original },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MetricSource>(
            "MetricSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MetricSource {
    const NAME: &'static str = "MetricSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.wire_protocol = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.original = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.wire_protocol != ::protobuf::EnumOrUnknown::new(WireProtocol::WIRE_PROTOCOL_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.wire_protocol.value());
        }
        if let Some(v) = self.original.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.wire_protocol != ::protobuf::EnumOrUnknown::new(WireProtocol::WIRE_PROTOCOL_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.wire_protocol))?;
        }
        if let Some(v) = self.original.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MetricSource {
        MetricSource::new()
    }

    fn clear(&mut self) {
        self.wire_protocol = ::protobuf::EnumOrUnknown::new(WireProtocol::WIRE_PROTOCOL_UNSPECIFIED);
        self.original = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MetricSource {
        static instance: MetricSource = MetricSource {
            wire_protocol: ::protobuf::EnumOrUnknown::from_i32(0),
            original: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MetricSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MetricSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MetricSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pulse.internode.v1.TagValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TagValue {
    // message fields
    // @@protoc_insertion_point(field:pulse.internode.v1.TagValue.tag)
    pub tag: ::bytes::Bytes,
    // @@protoc_insertion_point(field:pulse.internode.v1.TagValue.value)
    pub value: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:pulse.internode.v1.TagValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TagValue {
    fn default() -> &'a TagValue {
        <TagValue as ::protobuf::Message>::default_instance()
    }
}

impl TagValue {
    pub fn new() -> TagValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tag",
            |m: &TagValue| { &m.tag },
            |m: &mut TagValue| { &mut m.tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &TagValue| { &m.value },
            |m: &mut TagValue| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TagValue>(
            "TagValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TagValue {
    const NAME: &'static str = "TagValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tag = is.read_tokio_bytes()?;
                },
                18 => {
                    self.value = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.tag.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.tag);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.tag.is_empty() {
            os.write_bytes(1, &self.tag)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TagValue {
        TagValue::new()
    }

    fn clear(&mut self) {
        self.tag.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TagValue {
        static instance: TagValue = TagValue {
            tag: ::bytes::Bytes::new(),
            value: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TagValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TagValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TagValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TagValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pulse.internode.v1.MetricId)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MetricId {
    // message fields
    // @@protoc_insertion_point(field:pulse.internode.v1.MetricId.name)
    pub name: ::bytes::Bytes,
    // @@protoc_insertion_point(field:pulse.internode.v1.MetricId.metric_type)
    pub metric_type: ::std::option::Option<::protobuf::EnumOrUnknown<MetricType>>,
    // @@protoc_insertion_point(field:pulse.internode.v1.MetricId.tag_values)
    pub tag_values: ::std::vec::Vec<TagValue>,
    // special fields
    // @@protoc_insertion_point(special_field:pulse.internode.v1.MetricId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MetricId {
    fn default() -> &'a MetricId {
        <MetricId as ::protobuf::Message>::default_instance()
    }
}

impl MetricId {
    pub fn new() -> MetricId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &MetricId| { &m.name },
            |m: &mut MetricId| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "metric_type",
            |m: &MetricId| { &m.metric_type },
            |m: &mut MetricId| { &mut m.metric_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tag_values",
            |m: &MetricId| { &m.tag_values },
            |m: &mut MetricId| { &mut m.tag_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MetricId>(
            "MetricId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MetricId {
    const NAME: &'static str = "MetricId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_tokio_bytes()?;
                },
                16 => {
                    self.metric_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.tag_values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.name);
        }
        if let Some(v) = self.metric_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        for value in &self.tag_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_bytes(1, &self.name)?;
        }
        if let Some(v) = self.metric_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.tag_values {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MetricId {
        MetricId::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.metric_type = ::std::option::Option::None;
        self.tag_values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MetricId {
        static instance: MetricId = MetricId {
            name: ::bytes::Bytes::new(),
            metric_type: ::std::option::Option::None,
            tag_values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MetricId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MetricId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MetricId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pulse.internode.v1.WireProtocol)
pub enum WireProtocol {
    // @@protoc_insertion_point(enum_value:pulse.internode.v1.WireProtocol.WIRE_PROTOCOL_UNSPECIFIED)
    WIRE_PROTOCOL_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:pulse.internode.v1.WireProtocol.WIRE_PROTOCOL_CARBON)
    WIRE_PROTOCOL_CARBON = 1,
    // @@protoc_insertion_point(enum_value:pulse.internode.v1.WireProtocol.WIRE_PROTOCOL_STATSD)
    WIRE_PROTOCOL_STATSD = 2,
    // @@protoc_insertion_point(enum_value:pulse.internode.v1.WireProtocol.WIRE_PROTOCOL_PROM)
    WIRE_PROTOCOL_PROM = 3,
    // @@protoc_insertion_point(enum_value:pulse.internode.v1.WireProtocol.WIRE_PROTOCOL_OTLP)
    WIRE_PROTOCOL_OTLP = 4,
}

impl ::protobuf::Enum for WireProtocol {
    const NAME: &'static str = "WireProtocol";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WireProtocol> {
        match value {
            0 => ::std::option::Option::Some(WireProtocol::WIRE_PROTOCOL_UNSPECIFIED),
            1 => ::std::option::Option::Some(WireProtocol::WIRE_PROTOCOL_CARBON),
            2 => ::std::option::Option::Some(WireProtocol::WIRE_PROTOCOL_STATSD),
            3 => ::std::option::Option::Some(WireProtocol::WIRE_PROTOCOL_PROM),
            4 => ::std::option::Option::Some(WireProtocol::WIRE_PROTOCOL_OTLP),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<WireProtocol> {
        match str {
            "WIRE_PROTOCOL_UNSPECIFIED" => ::std::option::Option::Some(WireProtocol::WIRE_PROTOCOL_UNSPECIFIED),
            "WIRE_PROTOCOL_CARBON" => ::std::option::Option::Some(WireProtocol::WIRE_PROTOCOL_CARBON),
            "WIRE_PROTOCOL_STATSD" => ::std::option::Option::Some(WireProtocol::WIRE_PROTOCOL_STATSD),
            "WIRE_PROTOCOL_PROM" => ::std::option::Option::Some(WireProtocol::WIRE_PROTOCOL_PROM),
            "WIRE_PROTOCOL_OTLP" => ::std::option::Option::Some(WireProtocol::WIRE_PROTOCOL_OTLP),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [WireProtocol] = &[
        WireProtocol::WIRE_PROTOCOL_UNSPECIFIED,
        WireProtocol::WIRE_PROTOCOL_CARBON,
        WireProtocol::WIRE_PROTOCOL_STATSD,
        WireProtocol::WIRE_PROTOCOL_PROM,
        WireProtocol::WIRE_PROTOCOL_OTLP,
    ];
}

impl ::protobuf::EnumFull for WireProtocol {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("WireProtocol").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for WireProtocol {
    fn default() -> Self {
        WireProtocol::WIRE_PROTOCOL_UNSPECIFIED
    }
}

impl WireProtocol {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WireProtocol>("WireProtocol")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pulse.internode.v1.MetricType)
pub enum MetricType {
    // @@protoc_insertion_point(enum_value:pulse.internode.v1.MetricType.METRIC_TYPE_UNSPECIFIED)
    METRIC_TYPE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:pulse.internode.v1.MetricType.METRIC_TYPE_DELTA_COUNTER)
    METRIC_TYPE_DELTA_COUNTER = 1,
    // @@protoc_insertion_point(enum_value:pulse.internode.v1.MetricType.METRIC_TYPE_ABSOLUTE_COUNTER)
    METRIC_TYPE_ABSOLUTE_COUNTER = 2,
    // @@protoc_insertion_point(enum_value:pulse.internode.v1.MetricType.METRIC_TYPE_DELTA_GAUGE)
    METRIC_TYPE_DELTA_GAUGE = 3,
    // @@protoc_insertion_point(enum_value:pulse.internode.v1.MetricType.METRIC_TYPE_DIRECT_GAUGE)
    METRIC_TYPE_DIRECT_GAUGE = 4,
    // @@protoc_insertion_point(enum_value:pulse.internode.v1.MetricType.METRIC_TYPE_GAUGE)
    METRIC_TYPE_GAUGE = 5,
    // @@protoc_insertion_point(enum_value:pulse.internode.v1.MetricType.METRIC_TYPE_TIMER)
    METRIC_TYPE_TIMER = 7,
    // @@protoc_insertion_point(enum_value:pulse.internode.v1.MetricType.METRIC_TYPE_HISTOGRAM)
    METRIC_TYPE_HISTOGRAM = 8,
    // @@protoc_insertion_point(enum_value:pulse.internode.v1.MetricType.METRIC_TYPE_SUMMARY)
    METRIC_TYPE_SUMMARY = 9,
    // @@protoc_insertion_point(enum_value:pulse.internode.v1.MetricType.METRIC_TYPE_BULK_TIMER)
    METRIC_TYPE_BULK_TIMER = 10,
}

impl ::protobuf::Enum for MetricType {
    const NAME: &'static str = "MetricType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MetricType> {
        match value {
            0 => ::std::option::Option::Some(MetricType::METRIC_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(MetricType::METRIC_TYPE_DELTA_COUNTER),
            2 => ::std::option::Option::Some(MetricType::METRIC_TYPE_ABSOLUTE_COUNTER),
            3 => ::std::option::Option::Some(MetricType::METRIC_TYPE_DELTA_GAUGE),
            4 => ::std::option::Option::Some(MetricType::METRIC_TYPE_DIRECT_GAUGE),
            5 => ::std::option::Option::Some(MetricType::METRIC_TYPE_GAUGE),
            7 => ::std::option::Option::Some(MetricType::METRIC_TYPE_TIMER),
            8 => ::std::option::Option::Some(MetricType::METRIC_TYPE_HISTOGRAM),
            9 => ::std::option::Option::Some(MetricType::METRIC_TYPE_SUMMARY),
            10 => ::std::option::Option::Some(MetricType::METRIC_TYPE_BULK_TIMER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MetricType> {
        match str {
            "METRIC_TYPE_UNSPECIFIED" => ::std::option::Option::Some(MetricType::METRIC_TYPE_UNSPECIFIED),
            "METRIC_TYPE_DELTA_COUNTER" => ::std::option::Option::Some(MetricType::METRIC_TYPE_DELTA_COUNTER),
            "METRIC_TYPE_ABSOLUTE_COUNTER" => ::std::option::Option::Some(MetricType::METRIC_TYPE_ABSOLUTE_COUNTER),
            "METRIC_TYPE_DELTA_GAUGE" => ::std::option::Option::Some(MetricType::METRIC_TYPE_DELTA_GAUGE),
            "METRIC_TYPE_DIRECT_GAUGE" => ::std::option::Option::Some(MetricType::METRIC_TYPE_DIRECT_GAUGE),
            "METRIC_TYPE_GAUGE" => ::std::option::Option::Some(MetricType::METRIC_TYPE_GAUGE),
            "METRIC_TYPE_TIMER" => ::std::option::Option::Some(MetricType::METRIC_TYPE_TIMER),
            "METRIC_TYPE_HISTOGRAM" => ::std::option::Option::Some(MetricType::METRIC_TYPE_HISTOGRAM),
            "METRIC_TYPE_SUMMARY" => ::std::option::Option::Some(MetricType::METRIC_TYPE_SUMMARY),
            "METRIC_TYPE_BULK_TIMER" => ::std::option::Option::Some(MetricType::METRIC_TYPE_BULK_TIMER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MetricType] = &[
        MetricType::METRIC_TYPE_UNSPECIFIED,
        MetricType::METRIC_TYPE_DELTA_COUNTER,
        MetricType::METRIC_TYPE_ABSOLUTE_COUNTER,
        MetricType::METRIC_TYPE_DELTA_GAUGE,
        MetricType::METRIC_TYPE_DIRECT_GAUGE,
        MetricType::METRIC_TYPE_GAUGE,
        MetricType::METRIC_TYPE_TIMER,
        MetricType::METRIC_TYPE_HISTOGRAM,
        MetricType::METRIC_TYPE_SUMMARY,
        MetricType::METRIC_TYPE_BULK_TIMER,
    ];
}

impl ::protobuf::EnumFull for MetricType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MetricType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            MetricType::METRIC_TYPE_UNSPECIFIED => 0,
            MetricType::METRIC_TYPE_DELTA_COUNTER => 1,
            MetricType::METRIC_TYPE_ABSOLUTE_COUNTER => 2,
            MetricType::METRIC_TYPE_DELTA_GAUGE => 3,
            MetricType::METRIC_TYPE_DIRECT_GAUGE => 4,
            MetricType::METRIC_TYPE_GAUGE => 5,
            MetricType::METRIC_TYPE_TIMER => 6,
            MetricType::METRIC_TYPE_HISTOGRAM => 7,
            MetricType::METRIC_TYPE_SUMMARY => 8,
            MetricType::METRIC_TYPE_BULK_TIMER => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MetricType {
    fn default() -> Self {
        MetricType::METRIC_TYPE_UNSPECIFIED
    }
}

impl MetricType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MetricType>("MetricType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1fpulse/internode/v1/metric.proto\x12\x12pulse.internode.v1\"\xbd\
    \x01\n\tHistogram\x12>\n\x07buckets\x18\x01\x20\x03(\x0b2$.pulse.interno\
    de.v1.Histogram.BucketR\x07buckets\x12!\n\x0csample_count\x18\x02\x20\
    \x01(\x01R\x0bsampleCount\x12\x1d\n\nsample_sum\x18\x03\x20\x01(\x01R\ts\
    ampleSum\x1a.\n\x06Bucket\x12\x14\n\x05count\x18\x01\x20\x01(\x01R\x05co\
    unt\x12\x0e\n\x02le\x18\x02\x20\x01(\x01R\x02le\"\xcd\x01\n\x07Summary\
    \x12B\n\tquantiles\x18\x01\x20\x03(\x0b2$.pulse.internode.v1.Summary.Qua\
    ntileR\tquantiles\x12!\n\x0csample_count\x18\x02\x20\x01(\x01R\x0bsample\
    Count\x12\x1d\n\nsample_sum\x18\x03\x20\x01(\x01R\tsampleSum\x1a<\n\x08Q\
    uantile\x12\x1a\n\x08quantile\x18\x01\x20\x01(\x01R\x08quantile\x12\x14\
    \n\x05value\x18\x02\x20\x01(\x01R\x05value\"\xe3\x01\n\x0cDownstreamId\
    \x12#\n\x0clocal_origin\x18\x01\x20\x01(\x08H\0R\x0blocalOrigin\x12.\n\
    \x12unix_domain_socket\x18\x02\x20\x01(\tH\0R\x10unixDomainSocket\x12#\n\
    \x0cipv4_address\x18\x03\x20\x01(\rH\0R\x0bipv4Address\x12#\n\x0cipv6_ad\
    dress\x18\x04\x20\x01(\x0cH\0R\x0bipv6Address\x12)\n\x0finflow_provided\
    \x18\x05\x20\x01(\x0cH\0R\x0einflowProvidedB\t\n\x07id_type\"#\n\tBulkTi\
    mer\x12\x16\n\x06values\x18\x01\x20\x03(\x01R\x06values\"\xa4\x04\n\x06M\
    etric\x12,\n\x02id\x18\x01\x20\x01(\x0b2\x1c.pulse.internode.v1.MetricId\
    R\x02id\x12$\n\x0bsample_rate\x18\x02\x20\x01(\x01H\x01R\nsampleRate\x88\
    \x01\x01\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\x04R\ttimestamp\x12#\n\
    \x0csimple_value\x18\x04\x20\x01(\x01H\0R\x0bsimpleValue\x12=\n\thistogr\
    am\x18\x05\x20\x01(\x0b2\x1d.pulse.internode.v1.HistogramH\0R\thistogram\
    \x127\n\x07summary\x18\x06\x20\x01(\x0b2\x1b.pulse.internode.v1.SummaryH\
    \0R\x07summary\x12>\n\nbulk_timer\x18\n\x20\x01(\x0b2\x1d.pulse.internod\
    e.v1.BulkTimerH\0R\tbulkTimer\x12E\n\rmetric_source\x18\x07\x20\x01(\x0b\
    2\x20.pulse.internode.v1.MetricSourceR\x0cmetricSource\x12\x1f\n\x0brece\
    ived_at\x18\x08\x20\x01(\x04R\nreceivedAt\x12E\n\rdownstream_id\x18\t\
    \x20\x01(\x0b2\x20.pulse.internode.v1.DownstreamIdR\x0cdownstreamIdB\x0c\
    \n\nvalue_typeB\x0e\n\x0c_sample_rate\"\x83\x01\n\x0cMetricSource\x12E\n\
    \rwire_protocol\x18\x01\x20\x01(\x0e2\x20.pulse.internode.v1.WireProtoco\
    lR\x0cwireProtocol\x12\x1f\n\x08original\x18\x02\x20\x01(\x0cH\0R\x08ori\
    ginal\x88\x01\x01B\x0b\n\t_original\"2\n\x08TagValue\x12\x10\n\x03tag\
    \x18\x01\x20\x01(\x0cR\x03tag\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\
    \x05value\"\xb1\x01\n\x08MetricId\x12\x12\n\x04name\x18\x01\x20\x01(\x0c\
    R\x04name\x12D\n\x0bmetric_type\x18\x02\x20\x01(\x0e2\x1e.pulse.internod\
    e.v1.MetricTypeH\0R\nmetricType\x88\x01\x01\x12;\n\ntag_values\x18\x03\
    \x20\x03(\x0b2\x1c.pulse.internode.v1.TagValueR\ttagValuesB\x0e\n\x0c_me\
    tric_type*\x91\x01\n\x0cWireProtocol\x12\x1d\n\x19WIRE_PROTOCOL_UNSPECIF\
    IED\x10\0\x12\x18\n\x14WIRE_PROTOCOL_CARBON\x10\x01\x12\x18\n\x14WIRE_PR\
    OTOCOL_STATSD\x10\x02\x12\x16\n\x12WIRE_PROTOCOL_PROM\x10\x03\x12\x16\n\
    \x12WIRE_PROTOCOL_OTLP\x10\x04*\xa9\x02\n\nMetricType\x12\x1b\n\x17METRI\
    C_TYPE_UNSPECIFIED\x10\0\x12\x1d\n\x19METRIC_TYPE_DELTA_COUNTER\x10\x01\
    \x12\x20\n\x1cMETRIC_TYPE_ABSOLUTE_COUNTER\x10\x02\x12\x1b\n\x17METRIC_T\
    YPE_DELTA_GAUGE\x10\x03\x12\x1c\n\x18METRIC_TYPE_DIRECT_GAUGE\x10\x04\
    \x12\x15\n\x11METRIC_TYPE_GAUGE\x10\x05\x12\x15\n\x11METRIC_TYPE_TIMER\
    \x10\x07\x12\x19\n\x15METRIC_TYPE_HISTOGRAM\x10\x08\x12\x17\n\x13METRIC_\
    TYPE_SUMMARY\x10\t\x12\x1a\n\x16METRIC_TYPE_BULK_TIMER\x10\n\"\x04\x08\
    \x06\x10\x06b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(10);
            messages.push(Histogram::generated_message_descriptor_data());
            messages.push(Summary::generated_message_descriptor_data());
            messages.push(DownstreamId::generated_message_descriptor_data());
            messages.push(BulkTimer::generated_message_descriptor_data());
            messages.push(Metric::generated_message_descriptor_data());
            messages.push(MetricSource::generated_message_descriptor_data());
            messages.push(TagValue::generated_message_descriptor_data());
            messages.push(MetricId::generated_message_descriptor_data());
            messages.push(histogram::Bucket::generated_message_descriptor_data());
            messages.push(summary::Quantile::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(WireProtocol::generated_enum_descriptor_data());
            enums.push(MetricType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
